#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
//#include "LatoMedium10_degree.h"
#include "LatoMedium8_degree.h"
#include "ClosedCube_SHT31D.h"
#include "avdweb_VirtualDelay.h"

#include <ESP8266WiFi.h>
#include <DNSServer.h>
#include <ESP8266WebServer.h>
#include <Adafruit_MQTT.h>
#include <Adafruit_MQTT_Client.h>
#include <WiFiManager.h>         //https://github.com/tzapu/WiFiManager
#include <ESP8266mDNS.h>
#include <ESP8266WebServer.h>
#include <WebSocketsServer.h>
#include <FS.h>

#define AIO_SERVER      "io.adafruit.com"
#define AIO_SERVERPORT  1883                   // use 8883 for SSL
#define AIO_USERNAME "delhoume"
#define AIO_KEY "5cefb5958805493da7dc5610a4c47eb9"
#define TEMP_FEED "temperature"
#define HUMI_FEED "humidity"

WiFiClient wifiClient;
Adafruit_MQTT_Client mqtt(&wifiClient, AIO_SERVER, AIO_SERVERPORT, AIO_USERNAME, AIO_KEY);

Adafruit_MQTT_Publish mqttTemp = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/temperature");
Adafruit_MQTT_Publish mqttHum = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/humidity");

ESP8266WebServer webServer(80);       // Create a webserver object that listens for HTTP request on port 80
WebSocketsServer webSocket(81);    // create a websocket server on port 81

const char* mdnsName = "wemos"; // Domain name for the mDNS responder, connect to http://wemos.local

// degree is 176 (B0)
//fontconvert.exe Lato-Medium.ttf 10 32 176 > LatoMedium10_degree.h

// wemos I2C : D1 = SCL D2 = SDA

ClosedCube_SHT31D sht3xd;

#define OLED_RESET LED_BUILTIN
Adafruit_SSD1306 display(OLED_RESET);

const unsigned char wemos_logo_64x48_normal[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x38, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x38, 0x00, 0x70, 0x00, 0x00, 0x03, 0xFF, 0xF0,
  0x30, 0x00, 0x38, 0x00, 0x00, 0x07, 0x80, 0x78, 0x70, 0x00, 0x38, 0x00, 0x00, 0x0E, 0x1E, 0x1C,
  0x70, 0x00, 0x1C, 0x00, 0x00, 0x0C, 0xFF, 0x88, 0x60, 0x00, 0x1C, 0x00, 0x00, 0x01, 0xFF, 0xE0,
  0xE0, 0x00, 0x0C, 0x00, 0x00, 0x03, 0xC0, 0xE0, 0xE0, 0x00, 0x0E, 0x00, 0x00, 0x01, 0x1C, 0x60,
  0xE0, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x7F, 0x00, 0xE0, 0x00, 0x06, 0x00, 0x1C, 0x0E, 0x7F, 0x80,
  0xE0, 0x00, 0x06, 0x00, 0x1E, 0x1E, 0x21, 0x00, 0xE0, 0x00, 0x06, 0x00, 0x1E, 0x1E, 0x00, 0x00,
  0xE0, 0x00, 0x06, 0x1E, 0x1F, 0x3E, 0x0C, 0x1F, 0xE0, 0x18, 0x06, 0x33, 0x1B, 0x36, 0x3E, 0x38,
  0xE0, 0x18, 0x06, 0x71, 0x9B, 0x36, 0x3F, 0x38, 0x70, 0x1C, 0x0E, 0x7F, 0x99, 0xE6, 0x3F, 0x1E,
  0x70, 0x3E, 0x1C, 0x70, 0x18, 0xC6, 0x3F, 0x07, 0x3C, 0xFF, 0x3C, 0x30, 0x18, 0xC6, 0x1E, 0x03,
  0x1F, 0xE7, 0xF8, 0x3F, 0x18, 0xC6, 0x00, 0x3E, 0x0F, 0x83, 0xE0, 0x0C, 0x00, 0x00, 0x00, 0x18,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t WiFi_width = 60;
const uint8_t WiFi_height = 36;
const uint8_t WiFi_Logo[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xE0, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0x03, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0xFF, 0xFF, 0xFF, 0x07, 0xC0, 0x83, 0x01, 0x80, 0xFF, 0xFF, 0xFF, 
  0x01, 0x00, 0x07, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0x00, 
  0xC0, 0xFF, 0xFF, 0x7C, 0x00, 0x60, 0x0C, 0x00, 0xC0, 0x31, 0x46, 0x7C, 
  0xFC, 0x77, 0x08, 0x00, 0xE0, 0x23, 0xC6, 0x3C, 0xFC, 0x67, 0x18, 0x00, 
  0xE0, 0x23, 0xE4, 0x3F, 0x1C, 0x00, 0x18, 0x00, 0xE0, 0x23, 0x60, 0x3C, 
  0x1C, 0x70, 0x18, 0x00, 0xE0, 0x03, 0x60, 0x3C, 0x1C, 0x70, 0x18, 0x00, 
  0xE0, 0x07, 0x60, 0x3C, 0xFC, 0x73, 0x18, 0x00, 0xE0, 0x87, 0x70, 0x3C, 
  0xFC, 0x73, 0x18, 0x00, 0xE0, 0x87, 0x70, 0x3C, 0x1C, 0x70, 0x18, 0x00, 
  0xE0, 0x87, 0x70, 0x3C, 0x1C, 0x70, 0x18, 0x00, 0xE0, 0x8F, 0x71, 0x3C, 
  0x1C, 0x70, 0x18, 0x00, 0xC0, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x08, 0x00, 
  0xC0, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x0C, 0x00, 0x80, 0xFF, 0xFF, 0x1F, 
  0x00, 0x00, 0x06, 0x00, 0x80, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x07, 0x00, 
  0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 
  0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x1F, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x80, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };   

inline uint8_t centerV(uint8_t height) {
  return (display.height() - height) / 2;
}

inline uint8_t centerH(uint8_t width) {
  return (display.width() - width) / 2;
}

inline void displayWifiLogo() {
  display.drawXBitmap(centerH(WiFi_width), centerV(WiFi_height), 
                     WiFi_Logo, WiFi_width, WiFi_height, WHITE);
}

inline void displayText(const char* text, uint16_t xpos, uint16_t ypos) {
  display.setCursor(xpos, ypos);
  display.print(text);
}

void configModeCallback (WiFiManager *myWiFiManager) {
  display.clearDisplay();
  displayWifiLogo();
  displayText("SSID: ", 32, 55);
  displayText(myWiFiManager->getConfigPortalSSID().c_str(), 65, 55);
  display.display();
}

bool error = true;
float temp = 22.0;
float hum = 55.0;

void setup() {
  Serial.begin(9600);
  sht3xd.begin(0x45); // I2C address: 0x44 or 0x45
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C); //initialize with the I2C addr 0x3C (128x64) - 64x48 for wemos oled
   // show splash screen
   display.clearDisplay();
   display.drawBitmap(32, 16, wemos_logo_64x48_normal, 64, 48, WHITE);
  display.display();
  display.setTextColor(WHITE, BLACK);

  WiFiManager wifiManager;
  // make it longer for production
  wifiManager.setConfigPortalTimeout(120);
  wifiManager.setDebugOutput(true);
  wifiManager.setMinimumSignalQuality(20);
  wifiManager.setAPCallback(configModeCallback);
  wifiManager.autoConnect("wemos"); //  no password

  
  if (WiFi.isConnected()) {
    // start file system
    SPIFFS.begin(); 
    // start webSockets
    webSocket.begin();
    webSocket.onEvent(webSocketEvent);
    // start mDNS
    MDNS.begin(mdnsName);
    // start webserver
    webServer.onNotFound(handleNotFound);
    webServer.begin();
  }
}

String getContentType(String filename){
  if(filename.endsWith(".html")) 
    return "text/html";
  else if(filename.endsWith(".css")) 
    return "text/css";
  else if(filename.endsWith(".js")) 
    return "application/javascript";
  return "text/plain";
}

bool handleFileRead(String path) { // send the right file to the client (if it exists)
//  Serial.println("handleFileRead: " + path);
  if (path.endsWith("/")) path += "index.html";         // If a folder is requested, send the index file
   if (SPIFFS.exists(path)) {                            // If the file exists
      String contentType = getContentType(path);            // Get the MIME type
      File file = SPIFFS.open(path, "r");                 // Open it
      size_t sent = webServer.streamFile(file, contentType); // And send it to the client
      file.close();                                       // Then close the file again
      return true;
  }
  return false;                                         // If the file doesn't exist, return false
}

void handleNotFound() {
  if (!handleFileRead(webServer.uri()))
    webServer.send(404, "text/plain", "404: File Not Found");
}

// num is client id
void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      break;
    case WStype_CONNECTED:
      break;
    case WStype_TEXT: // always send back JSON string
      sendWebSocketValues(num);
      break;
    default:
    break;
  }
}

const char* json = "{\"t\":\"%.1f\",\"h\":\"%.1f\"}";
    
void sendWebSocketValues(uint8_t num) {
       // send to websockets as JSON string
       // send nothing if error
      if (error ==  false) {
        static char buffer[32];
        sprintf(buffer, json, temp, hum);
//        Serial.println(buffer);
        webSocket.sendTXT(num, buffer);
      } 
    } 

uint8_t rssiToQuality(long rssi) {
     // -120 to 0 DBm
   uint8_t quality;
   if(rssi <= -100)
     quality = 0;
   else if(rssi >= -50)
     quality = 100;
   else
     quality = 2 * (rssi + 100);
  return quality;
}


void displayConnectionStatus(uint16_t startx, uint16_t starty) {
    if (WiFi.isConnected()) {
      uint8_t quality = rssiToQuality(WiFi.RSSI());
      uint16_t offset = 4;
      if (quality >= 10)
        display.fillRect(startx, starty - 3, 3, 3, WHITE);
      else
        display.drawRect(startx, starty - 3, 3, 3, WHITE);
      startx += offset;
      if (quality >= 25)
        display.fillRect(startx, starty - 5, 3, 5, WHITE);
      else
        display.drawRect(startx, starty - 5, 3, 5, WHITE);
      startx += offset;
       if (quality >= 50)
        display.fillRect(startx, starty - 7, 3, 7, WHITE);
      else
        display.drawRect(startx, starty - 7, 3, 7, WHITE);
      startx += offset;
       if (quality >= 80)
        display.fillRect(startx, starty - 9, 3, 9, WHITE);
      else
        display.drawRect(startx, starty -9, 3, 9, WHITE);
      }
 }

VirtualDelay delayValues;
VirtualDelay delayDisplay;
VirtualDelay delayMqtt;

void loop() {
  // is it necessary when only publishing data ?
    webSocket.loop();
    webServer.handleClient();

    delayValues.start(2000);
    delayDisplay.start(1500);
    delayMqtt.start(10000);
    if (delayValues.elapsed()) {
      updateValues();
     }
    if (delayMqtt.elapsed()) {
     sendMQTTValues();
     }
    if (delayDisplay.elapsed()) {
      displayValues();
    }
}

void updateValues() {
//  SHT31D result = sht3xd.readTempAndHumidity(SHT3XD_REPEATABILITY_HIGH, SHT3XD_MODE_POLLING, 50);
  SHT31D result = sht3xd.readTempAndHumidity(SHT3XD_REPEATABILITY_LOW, 
                                             SHT3XD_MODE_CLOCK_STRETCH, 50);
  if (result.error == SHT3XD_NO_ERROR) {
    // bad temp read when sensor is not isolated, CALIBRATION !!
    temp = round((result.t - 8.0) * 10.0) / 10.0;
    hum = round((result.rh  + 12.0) * 10.0) / 10.0;
    error = false;
  } else {
    error = true;
  }
}

int xtemp = 45;
int xhum = 45;
int ytemp = 45;
int yhum = 60;

void sendMQTTValues() {
//Serial.println("Sending values to MQTT");
 if (error == false) {
    if (!mqtt.connected()) {
      //     Serial.println("Not connected to MQTT");
      mqtt.connect();
    }
     if (mqtt.connected()) {
        //    Serial.println("Connected to MQTT");
        mqttTemp.publish(temp);
        mqttHum.publish(hum);
      }
   }
}

void displayValues() {
  display.clearDisplay();
  //display.setFont(&Lato_Medium10pt8b);
  display.setFont(&Lato_Medium8pt8b);
  static char buffer[10];
  if (error == false) {
    if (temp < 0) 
     displayText("-", xtemp - 6, ytemp);


      dtostrf(fabs(temp), 4, 1, buffer);  
      buffer[4] = ' '; // space
     buffer[5]= 176; // degree
     buffer[6] = 0;
     displayText(buffer, xtemp, ytemp);
     
     dtostrf(hum, 4, 1, buffer);
    buffer[4]= '%';
     buffer[5] = 0;
     displayText(buffer, xhum, yhum);
     
      // one decimal place
     // Serial.print(round(temp * 10.0) / 10.0);
     //Serial.print(",");
    //Serial.println(round(hum * 10.0) / 10.0);
 
   } else {
    // TODO : display a bitmap
   // displayText(" :-( ", 35, 45);
 //   Serial.println("Error");
  }
  displayConnectionStatus(70, 28);
   display.setFont();
  if (mqtt.connected()) 
        displayText("mqtt", 35, 22);

  display.display();
  // display to serial to plot in IDE
}

